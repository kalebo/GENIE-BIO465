---
title: "PipelineDevelopment"
author: "Kaleb Olson"
date: "April 13, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(viridis)
library(dplyr)
library(reshape2)
library(magrittr)
library(readr)
library(synapseClient)
library(doParallel)
library(tidyverse)
library(data.table)
```

If you have a synapse log in, you run this cell and download the raw data files from GENIE.
```{r}
synapseLogin()
```

Load all the data we want to work with. Most has been filtered by us and saves having to rerun computationally complex and time consuming commands.
```{r}
genie.filtered.cn <- readRDS("genie-filtered-cn.rds")
gdsc.filtered.cn <- readRDS("gdsc-filtered-cn.rds")
gdsc.filtered.cn.t <- readRDS("gdsc-filtered-cn-t.rds")

celline.to.cosmicid <- readRDS("gdsc-cellline-to-cosmic-id.rds")
screeened.compounds <- readRDS("screened-compounds.rds")
dose.response <- readRDS("dose-response.rds")

genie.clin <- readRDS("genie-clin.rds")
intersecting.genes <- readRDS("intersecting-genes.rds")
genie.filtered.cnclin <- readRDS("genie-filtered-cn-clin.rds")


genie.subsets.cn.profiles.old <- readRDS("genie.subsets.cn.profiles.rds")
gdsc.subsets.cn.profiles <- readRDS("Drug-Profile-Table.rds")
genie.subsets2060.cn.profiles <- readRDS("latest.genie.subset.cn.profiles.rds")
```

Make a tree map breakdown of cancer and cancer sub-type.
```{r}
#test.count <- genie.clin %>% group_by(CANCER_TYPE_DETAILED) %>% mutate(COUNT = n())
#png(filename="tree.png",width=1024, height=600);
#treemap(test.count, index=c("CANCER_TYPE", "CANCER_TYPE_DETAILED"), vSize = "COUNT", type="index", palette= "Reds", align.labels = list(c("center", "center"), c("right", "bottom")), title="GENIE - Breakdown by cancer and cancer sub-type", fontsize.labels=c(18,10), fontsize.title = 18);
#dev.off()
```

Example of how genie.filtered.cnclin is generated:
```
syn.clin <- synGet('syn7851246')
genie.clin <- read_tsv(syn.clin@filePath)
genie.filtered.cn.cst <- melt(genie.filtered.cn) %>% dcast(variable ~ ...)
colnames(genie.filtered.cn.cst)[1] <- "SAMPLE_ID"
genie.filtered.cnclin <- inner_join(genie.clin, genie.filtered.cn.cst)
saveRDS(genie.filtered.cnclin, "genie-filtered-cn-clin.rds")
```


-----------------------------------------------------Subtyping GENIE -----------------------------------------------------------
Do some additional processing of the genie copy level data. We will transpose the matrix to make it tidy. Rename column headers and make the rows into actual values and label the column.
```{r}
#transpose the genie filtered CN df
genie.filtered.cn.t <- t(genie.filtered.cn)
#Strip first row 
genie.filtered.cn.t<- as.data.frame(genie.filtered.cn.t[-1,])
# Rename Columns to be the matching genes which we know are in the same order
colnames(genie.filtered.cn.t) <- unlist(intersecting.genes)
#Make the rownames into values
genie.filtered.cn.t <- setDT(genie.filtered.cn.t,keep.rownames = TRUE)[]
# make the first column header to be SAMPLE_ID
colnames(genie.filtered.cn.t)[1] <- "SAMPLE_ID"
# Now its all READY!!!

```

Generate of all our parameter vectors and lists to run through our filter string generation pipeline to create many subsets of the genie database.
```{r}
# grab the cancer types
genie.cancer.types <- setDT(genie.cancer.types,keep.rownames = TRUE)[]
colnames(genie.cancer.types)[2] <- "Count"
# only grab those with over 150 records total before any filtering
cancer_types <- filter(genie.cancer.types, Count > 150) %>% arrange(desc(Count))
cancer_types <- c(cancer_types[,1])

#Sex vector
sexes<- c("Male","Female")

#races vector
races <- c("White", "Black", "Asian")

#copy levels vector
cnlevels <- c(-2,-1,1,2)

# Ages
# Must be a list of lists if you desire multiple age groupings as we did. Must give (lower bound, upper bound)
ages <- list(list(0,18),list(19,30),list(31,40),list(19,40))
```

Make map data structure: key = cancer -> value = subtypes of that cancer
This is more complex than generating the other parameters so we stuck it in a new cell
```{r}
cancerPairedWithSubtypes <- new.env()
for (cancer in cancer_types){
  t <- filter(genie.clin,genie.clin$CANCER_TYPE == cancer)
  #print(cancer)
  name <- paste(cancer,"Subtypes")
  name <- gsub(" ","",name)
  subtypes <- summary(factor(t$CANCER_TYPE_DETAILED))
  #print(class(name))
  #print(cancer)
  
  cancerPairedWithSubtypes[[cancer]] <- subtypes[subtypes >25]

}
```


Function that builds each individual filter String.
It builds a long string that will be interpretted as a command line call later on.
```{r}

singleFilterSet <- function(cancer=NA, cancer_subtype=NA, sex=NA, race=NA, age= NA) {
  result = ""
  if (!is.na(cancer)) result <- paste(result, "CANCER_TYPE == '", cancer, "'", sep = "")
  if (!is.na(cancer_subtype)) result <- paste(result, ", CANCER_TYPE_DETAILED == '", cancer_subtype, "'", sep = "")
  if (!is.na(sex)) result <- paste(result, ", SEX == '", sex, "'", sep = "")  
  if (!is.na(race)) result <- paste(result, ", PRIMARY_RACE == '", race, "'", sep = "")
  if (!is.na(age)) result <- paste(result, ", AGE_AT_SEQ_REPORT >= ", age[1], ", AGE_AT_SEQ_REPORT < ", age[2], sep = "")
  result
}

```

Generate and Clean up results from generateFilters function
##### NOTE ####
Run the generateAllFilters cells below first. They are rather long cells so are at the end of the file but are required for this function.
```{r}
# this script contains lengthy funtions to create all the unique filters from the parameters defined.
# Necessary dependency functions for makeFilters()
# the makeFilters function will call functions in this script for you
source("generateUniqueFilters.R")
makeFilters <- function(cancers = NA, cancer_subtypes=NA, sexes = NA, races = NA, ages = NA ){
  filterStringsAll <- as.data.frame(generateAllFilters(cancers,cancer_subtypes,sexes,races,ages))
  filterStringsAll <- setDT(filterStringsAll,keep.rownames = TRUE)[]
  colnames(filterStringsAll)[1] <- "ID"
  colnames(filterStringsAll)[2] <- "FilterString"
  filterStringsAll$ID <- as.integer(filterStringsAll$ID)
  filterStringsAll$FilterString <- as.character(filterStringsAll$FilterString)
  return(filterStringsAll)
}
```
Generate our filter Strings based on the parameters we defined above
```{r}
allFilters <- makeFilters(cancer_types,cancerPairedWithSubtypes,sexes,races,ages)
head(allFilters)
```

Function to generate the genie subsets as well as generate the CN Profiles. It makes the subset based on a filter String generated elsewhere. The filter String contains the Cancer type, subtype, and any sex, age or race filter. It gets prepended with the necessary commands to run in an eval expression. The cn level is one of the five discrete copy levels (-2,-1,0,1,2) which is passed inot a function that builds a propotional profile on that copy level.
```{r}
makeGenieSubsetProfile <- function(filterString, cnlevel){
  
  # create entire filter command in one string
  filterString1 <- paste('filter(genie.clin,',filterString,")")  
  # run the filter command
  subsetClinical <- eval(parse(text=filterString1))
  records <- filter(genie.filtered.cn.t, SAMPLE_ID %in% subsetClinical$SAMPLE_ID)
  #We declare that we need at least 25 records after filtering to have enough samples to build a representative profile.
  if (nrow(records) < 25){
    return(NA)
  }
  else{
    #generate profile and return it
    return(mkProfile(records, cnlevel))
  }
}
```


Make Profile Table from the generated Filter Strings. This is the overarching function to generate our entire table of profiles by filter and copy level. We pass in the cn levels we want to use. We used only (-2,-1,1,2) in our analysis. The filtersDF is a data frame with two columns, ID and Filter String. The Filter String object is a string detailing which parameters to use to build the subset, namely, cancer, cancer subtype, sex, race and age.
We then append each resulting profile to a larger Data frame. The profiles are the proportion of one cn level expression per gene which is all stored in one row. After all the profiles is generated, we edit colnames to be accurate.
```{r}
makeGenieProfileTable <- function(cnlevels,filtersDF){
  headerLine <- c("FILTER_ID", "CN_LEVEL", unlist(intersecting.genes))
  genie.subset.cn.profiles <- (data.frame(matrix(ncol = length(headerLine),nrow =0)))
  for (filter_id in filtersDF$ID){
    for (copylevel in cnlevels){
     
      subsetFilter <- filter(filtersDF,ID == filter_id)
      
      genieProfile<-makeGenieSubsetProfile(subsetFilter[,2],copylevel)
      
      #make row
      if(!is.na(genieProfile)){
        genie.subset.cn.profiles <- rbind(genie.subset.cn.profiles,c(filter_id,copylevel,unlist(genieProfile)[-1]))
      }
    }
  }
  
  colnames(genie.subset.cn.profiles) <- headerLine
  genie.subset.cn.profiles
}
```


Command we ran to generate our genie profile table
```{r}
genie.subset.cn.profiles <- makeGenieProfileTable(cnlevels, allFilters)

head(genie.subset.cn.profiles)
```



Here is how the transposed and trimmed version of gdsc.filtered.cn was generated
```{r}
gdsc.filtered.cn.t <- as.data.frame(t(gdsc.filtered.cn))[c(-2, -3, -4),]

```


Here we check the gene EFGR (row number 138 in each dataset because we ordered genes alphabetically) to check that we get a comparable distribution of cnv values. This depends on an accurate translation of cnv data from gdsc style to genie style. The EFGR gene can be considered as a baseline because ...
```{r}
gdsc.efgr <- table(sapply( gdsc.filtered.cn[138, 5:ncol(gdsc.filtered.cn)],  translate))
genie.efgr <- table(unlist(genie.filtered.cn[138, 2:ncol(genie.filtered.cn) ]))
sapply(gdsc.efgr, function(x) x/ncol(gdsc.filtered.cn))
sapply(genie.efgr, function(x) x/ncol(genie.filtered.cn))

```
ERBB2
```{r}
gdsc.efgr <- table(sapply( gdsc.filtered.cn[150, 5:ncol(gdsc.filtered.cn)],  translate))
genie.efgr <- table(unlist(genie.filtered.cn[150, 2:ncol(genie.filtered.cn) ]))
sapply(gdsc.efgr, function(x) x/ncol(gdsc.filtered.cn))
sapply(genie.efgr, function(x) x/ncol(genie.filtered.cn))

```

Question: how many times does max not equal min in the unconverted GDSC data?
```{r}
maxeqmin <- function(x) {
  max_r <- substr(x, 1,1)
  min_r <- substr(x, 3,3)
  max_r == min_r
}


tout <- apply(gdsc.filtered.cn.t[2:nrow(gdsc.filtered.cn.t),], c(1,2), maxeqmin)
table(tout)

```
Question: how many times do we find that if the two don't match that the max is greater than 8
```{r}
maxneandgt8 <- function(x) {
  quad <- unlist(strsplit(x, ","))
  max_r <- quad[1]
  min_r <- quad[2]
  max_i = as.numeric(max_r)
  
  if (max_i != min_r){
     max_i >= 4
  }
  else {
    FALSE
  }
}
mout <- apply(gdsc.filtered.cn.t[2:nrow(gdsc.filtered.cn.t), ], c(1,2), maxneandgt8)
table(mout)
```

```{r}
bettertrans <- function(x){ 
  quad <- unlist(strsplit(x, ","))
  max_i <- as.numeric(quad[1])
  min_i <- as.numeric(quad[2])
  
  if (max_i == 0){
    -2
  }
  else if (max_i == 1) {
    -1
  }
  else if (max_i <= 3) {
    0
  }
  else if (max_i <= 8 && min_i < 8 ) {
    1
  }
  else {
    2
  }
}

gdsc.filtered.cn.bettertrans <- apply(gdsc.filtered.cn.t[2:nrow(gdsc.filtered.cn.t), ], c(1,2), bettertrans)
gdsc.cn.table <- as.data.frame(table(gdsc.filtered.cn.bettertrans))
colnames(gdsc.cn.table) <- c("cn", "freq")
```

```{r}
wipenonextr <- function(x){
  if (x != -2 || x != 2) {
    0
  }
  else {
    x
  }
}

sum(genie.filtered.cn[,2:ncol(genie.filtered.cn)] == -2) +
sum(genie.filtered.cn[,2:ncol(genie.filtered.cn)] == 2)
```

Make a plot of the distribution:
```{r}
genie.cn.table <- as.data.frame(table(unlist(genie.filtered.cn[,2:ncol(genie.filtered.cn)])))
colnames(genie.cn.table) <- c("cn", "freq")
```

```{r}
library(scales)
ggplot(genie.cn.table[-2,]) + geom_col(aes(x = cn, y = freq), fill="#B22222") + scale_y_log10( breaks = trans_breaks("log10", function(x) 10^x), labels = trans_format("log10", math_format(10^.x))) + labs(x="Discrete CN Level", y ="Count", title="GENIE Copy Number Distribution")

ggplot(gdsc.cn.table) + geom_col(aes(x = cn, y = freq), fill="#B22222") + scale_y_log10( breaks = trans_breaks("log10", function(x) 10^x), labels = trans_format("log10", math_format(10^.x))) + labs(x="Discrete CN Level", y ="Count", title="Translated GDSC Copy Number Distribution")
```


Now we choose a drug that is has at least one record that is very low IC50. In this case #104. We filter for this drug and any record that is less than our threshold of -2 for IC50
```{r}
gdsc.filtered.cn.bettertrans.df <- as.data.frame(gdsc.filtered.cn.bettertrans)
colnames(gdsc.filtered.cn.bettertrans.df) <- unlist(intersecting.genes)

library(data.table)
gdsc.filtered.cn.bettertrans.df <- setDT(gdsc.filtered.cn.bettertrans.df, keep.rownames = TRUE)[]
colnames(gdsc.filtered.cn.bettertrans.df)[1] <- "COSMIC_ID"

```

Now we show a trivial example of how we are going to compare profile sets. Note- that we will need to consider the positive 2 and the negative 2 cases individually.
```{r}
drug_id = 104
drug.experiments <- filter(dose.response, DRUG_ID == drug_id, LN_IC50 < -2)
profilein.2 <- filter(gdsc.filtered.cn.bettertrans.df, COSMIC_ID %in% drug.experiments$COSMIC_ID)

drug_id = 201
drug.experiments <- filter(dose.response, DRUG_ID == drug_id, LN_IC50 < -2)
profilein.1 <- filter(gdsc.filtered.cn.bettertrans.df, COSMIC_ID %in% drug.experiments$COSMIC_ID)

profile.104 <- apply(unlist(profilein.2 == 2), 2, function(x) sum(x)/length(x))
profile.201 <-  apply(unlist(profilein.1 == 2), 2, function(x) sum(x)/length(x))
dist(rbind(profile.201, profile.104), method = "euclidian")
```

We generalize the above as functions:
```{r}
colProp <- function(col) {sum(col)/length(col)}

mkProfile <- function(set, cnlevel) {
  props <- apply(unlist(set == cnlevel), 2, colProp)
  props <- props - mean(props)
  props
}

profileDist <- function(p1, p2) {dist(rbind(p1, p2), method = "euclidian")}

subsetDist <- function(set_a, set_b, cnlevel) {
  profileDist(mkProfile(set_a, cnlevel), mkProfile(set_b, cnlevel))
}

compareDrugs <- function(drug_id1, drug_id2, threshold, cnlevel) {
  mkRecordSet <- function(drug_id, threshold) {
    drug.experiments <- filter(dose.response, DRUG_ID == drug_id, LN_IC50 < threshold)
    records <- filter(gdsc.filtered.cn.bettertrans.df, COSMIC_ID %in% drug.experiments$COSMIC_ID)
    #assertthat::assert_that(length(records) >= 100)
    records
  }
  
  subsetDist(mkRecordSet(drug_id1, threshold), mkRecordSet(drug_id2, threshold), cnlevel)
}

```

This is where we rank the Strongest Drugs by LN and AUC
```{r}
#Drugs with most cell line responders.
strongestDrugs <- dose.response %>% filter(LN_IC50 < -2, AUC > .5) %>% group_by(DRUG_ID) %>% summarise(drugPower = sum(LN_IC50 < -2)) %>% arrange(desc(drugPower))

testableDrugs <- filter(strongestDrugs, drugPower > 10, drugPower < 100)

creamTestDrugs <- filter(dose.response, dose.response$DRUG_ID %in% testableDrugs$DRUG_ID, LN_IC50 < -2, AUC > .5) %>% arrange(DRUG_ID, LN_IC50)
testd <- data.table(creamTestDrugs)
setkey(testd, DRUG_ID)
creamTestDrugs <- testd[, lapply(.SD, function(x) head(x,10)), by = key(testd)]

# How many entries are eliminated by filtering AUC
LN_Filtered_Count <- dose.response %>% filter(LN_IC50 < -2) %>% nrow()
LN_AUC_filtered_Count <- dose.response %>% filter(LN_IC50 < -2, AUC > .5) %>% nrow()
AUC_Count <- LN_Filtered_Count - LN_AUC_filtered_Count
AUC_Count
#filter(strongestDrugs, stronge)
```


```{r}
# Create GDSC Drug Id CNLevel Profile Table, Parameters = cnLevels v(), drugIds v(), IC_50 threshold
makeDrugCNProfileTable <- function(cnlevels, drugIDs, threshold){
  headerLine <- c("DRUG_ID", "CN_LEVEL", unlist(intersecting.genes))
  gdsc.drug.cn.profile <- data.frame(matrix(ncol = length(headerLine), nrow = 0))
  for(drugID in drugIDs)
  {
    for(copyLevel in cnlevels)
    {
    drug.experiments <- filter(creamTestDrugs, DRUG_ID == drugID, LN_IC50 < threshold)
    records <- filter(gdsc.filtered.cn.bettertrans.df, COSMIC_ID %in% drug.experiments$COSMIC_ID)
    profile <- mkProfile(records, copyLevel)
    gdsc.drug.cn.profile <- rbind(gdsc.drug.cn.profile, c(drugID, copyLevel, unlist(profile)[-1]))
    }
  }
  colnames(gdsc.drug.cn.profile) <- headerLine
  return (gdsc.drug.cn.profile)
}

```

Generate GDSC drug profile table
```{r}
gdsc.subsets.cn.profiles <- makeDrugCNProfileTable(c(-2, -1, 1, 2), testableDrugs$DRUG_ID, -2)
```





```{r}

  mkRecordSet <- function(drug_id, threshold) {
    drug.experiments <- filter(dose.response, DRUG_ID == drug_id, LN_IC50 < threshold)
    records <- filter(gdsc.filtered.cn.bettertrans.df, COSMIC_ID %in% drug.experiments$COSMIC_ID)
    assertthat::assert_that(length(records) >= 100)
    records
  }

```

Where we checked to see if CDKN2B occurred most frequently as max gene.
```{r}
ids <- arrange(dose.response, LN_IC50)$DRUG_ID
trt<- function(id) {which.max((mkProfile(mkRecordSet(id, 2), -2)))}
sapply(unlist(ids[1:50]), trt)
```
Let's try plotting above.
```{r}
#install.packages("ggrepel") 
library("ggrepel")
profbyid <- function(id) {
  res <- as.data.frame(mkProfile(mkRecordSet(id, 2), -2))
  colnames(res) <- "SCORE"
  res <- tibble::rownames_to_column(res, "GENE")
  res
}

plotDrug <- function(id) {
  profile <- profbyid(id)
  name <- select(filter(screeened.compounds, `Drug ID` == id), `Drug Name`) 
  ggplot(profile, aes(x=GENE, y=SCORE)) + scale_y_log10() + geom_point() + geom_text_repel(data= subset(profile, SCORE > 0.001), aes(label=GENE), size = 3) + theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) + annotation_logticks(side="l") + labs(title = paste(name ," (", id, ") ", "CNV profile", sep=""))
}
```

```{r}

plotFilteredSubset <- function(id) {
  # NOT WORKING YET
  profile <- as.data.frame(filter(genie.subsets.cn.profiles, FILTER_ID == id)[,c(-1, -2)])
  colnames(profile) <- "SCORE"
  res <- tibble::rownames_to_column(res, "GENE")
  
  name <- "TODO"
  ggplot(profile, aes(x=GENE, y=SCORE)) + scale_y_log10() + geom_point() + geom_text_repel(data= subset(profile, SCORE > 0.001), aes(label=GENE), size = 3) + theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) + annotation_logticks(side="l") + labs(title = paste(name ," (", id, ") ", "CNV profile", sep=""))
}


```

Here is the function that will get the distance from each GENIE tumour subset to each GDSC drug subset.
```{r}
getTumourDrugDist <- function(subsetid, subsetTable, drugid, drugTable, cnlevels){
  totalDist = 0
  for (level in cnlevels) {
    subsetprofile <- unlist(filter(subsetTable, FILTER_ID == subsetid, CN_LEVEL == level)[,c(-1, -2)])
    drugprofile <- unlist(filter(drugTable, DRUG_ID == drugid, CN_LEVEL == level)[,c(-1, -2)])
    totalDist <- totalDist + profileDist(subsetprofile, drugprofile)
  }
  totalDist
}



rankDrugsBySubset <- function(subsetid, cnlevels) {
  sapply(unique(gdsc.subsets.cn.profiles$DRUG_ID), getTumourDrugDist, subsetid = subsetid, subsetTable = genie.subsets.cn.profiles, drugTable = gdsc.subsets.cn.profiles, cnlevels = cnlevels)
}

generateTumourDrugMatrix <- function(subsetprofile.df, drugprofile.df, cnlevels) {
  resultsTable <- as.data.frame(matrix(ncol = length(unique(drugprofile.df$DRUG_ID)), nrow = 0))
  for (subsetprofile in unique(subsetprofile.df$FILTER_ID)){
        cancerSubset_Row <- vector(mode = 'double')
    for (drugprofile in unique(drugprofile.df$DRUG_ID)){
      distance <- getTumourDrugDist(subsetprofile, subsetprofile.df, drugprofile, drugprofile.df, cnlevels)
      cancerSubset_Row <- append(cancerSubset_Row, distance)
    }
    resultsTable <- rbind(resultsTable, cancerSubset_Row)
  }
  colnames(resultsTable) <- unlist(unique(drugprofile.df$DRUG_ID))
  rownames(resultsTable) <- unlist(unique(subsetprofile.df$FILTER_ID))
  return (resultsTable)
}

```

```{r}
ResultsMatrix <- readRDS("allTestResults.rds")

#ResultsMatrix <- generateTumourDrugMatrix(genie.subsets2060.cn.profiles, gdsc.subsets.cn.profiles, c(-2,2))
# run if you do not read in the rds file but rather run the time consuming command above 
#ResultsMatrix <- setDT(as.data.frame(ResultsMatrix), keep.rownames = TRUE)[]
#colnames(ResultsMatrix)[1]<- "FILTER_ID"
#the .rds file has already been formatted for you
```

Plot our heat map of the top 50 performing filtered genie subsets across our 16 drugs
```{r}

ResultsMatrix.m <- melt(ResultsMatrix)
colnames(ResultsMatrix.m) <- c("FILTER_ID", "DRUG_ID", "SCORE")

#grabbing the top 250 scores give us the top 60 filter IDs
ResultsMatrix60.m <-arrange(ResultsMatrix.m, SCORE)[1:250,]
#quick function to replace the DRUG ID with its actual name
drugName <- function(id){
  select(filter(screeened.compounds,`Drug ID` == id), `Drug Name`)
}


Best60FilterIDs <- unique(select(ResultsMatrix60.m, FILTER_ID))
Best60Results <- filter(ResultsMatrix.m, FILTER_ID %in% Best60FilterIDs$FILTER_ID)
Best60Results$DRUG_ID<- unlist(sapply(Best60Results$DRUG_ID,drugName))
ggplot(Best60Results, 
          aes(y = DRUG_ID, x = FILTER_ID)) + 
          geom_tile(aes(fill = SCORE)) + 
          scale_fill_viridis(option = "magma", direction = -1) + theme(
              axis.text.x = element_text(angle = 45,size = 14, hjust = 1,vjust = 1),
              axis.text.y = element_text(size = 14),
              axis.title = element_text(size = 20, face = "bold"),
              plot.title = element_text(size = 30, hjust = .5, face = "bold"),
              plot.background = element_blank()) +
          labs(title = "Drug CNV Score Matrix", y = "Drug Name", x = "Subset ID", key = "Score") +
          scale_y_discrete(expand = c(0, 0)) +
          scale_x_discrete(expand = c(0, 0))


```

Plot Histogram of top 50 matches
```{r}
histogramResults <- arrange(ResultsMatrix.m, SCORE)[1:60,]
histogramResults$DRUG_ID<- unlist(sapply(histogramResults$DRUG_ID,drugName))
ggplot(data = histogramResults, 
       aes(x=reorder(DRUG_ID, DRUG_ID, function(x) - length(x)), fill = "red")) + 
       geom_bar() + guides(fill = FALSE) + 
       labs(title = "Drug Distribution Among Best Cancer Groups",x = "Drug Name", y = "Count") + 
       theme(axis.text.x=element_text(angle=45, hjust=1), 
             axis.title = element_text(size = 14),
             plot.title = element_text(hjust = .5, size = 14))
```
